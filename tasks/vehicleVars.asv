%% Vehicle Nonlinear Variables
% This file was derived from the work by Peter Corke and Fabian Reither.
% Copyright (C) 1993-2015, by Peter I. Corke
%
% This file is part of The Robotics Toolbox for MATLAB (RTB).
%
% http://www.petercorke.com

% Copyright 2013-2017 The MathWorks, Inc.

% 6DOF
Vehicle.SixDOF.initGreenwich = 0;
Vehicle.SixDOF.quatGain = 1;
% Position on Earth
Vehicle.PositionOnEarth.href = -init.posLLA(3);
Vehicle.PositionOnEarth.FlatEarthToLLA.xAxis = 0;
%% Physical properties
% Airframe
switch (model)
    case 'Mambo'
        Vehicle.Airframe.mass = 0.063;
        Vehicle.Airframe.inertia = diag([0.0000582857 0.0000716914 0.0001]);
    case 'RollingSpider'
        Vehicle.Airframe.mass = 0.068;
        Vehicle.Airframe.inertia = diag([0.0686e-3 0.092e-3 0.1366e-3]);
    case 'UavMgr'
        Vehicle.Airframe.mass = 1.6;
        % Inertia calculated from 3D model. Parts of the model have wrong material
        % settings and the final mass is not proper. Calculater inertia values were
        % divided by model weight and multiplied by the real weight.
        Vehicle.Airframe.inertia = diag([0.03858 0.04146 0.05935]);
        % Estimated as rectangle 
        % Vehicle.Airframe.inertia = diag([0.0221866 0.0221866 0.04266]); 
end

% Distance between the middle of the airframe and the single rotor in a
% straight line
Vehicle.Airframe.d = 0.285; %OK
% Distance between the middle of the airframe and the single rotor along X
% and Y axes
Vehicle.Airframe.xy = Vehicle.Airframe.d*sqrt(2)/2; % For diamond rotor set-up
% Distance between the ground and the middle of the airframe? or bottom?
% 26cm is a distance to the center of the frame
Vehicle.Airframe.h = -0.26; 

Vehicle.Airframe.Cdx = 0; % Not changed
Vehicle.Airframe.Cdy = 0; % Not changed
% Distance between a bottom and a top of the airframe (aiframe thickness??)
% - not sure but small, light element like propeller, PCB, small baterry should be
% excluded
Vehicle.Airframe.diameter = .08; % For drag calculation purposes

% Rotor
% Number of blades
Vehicle.Rotor.blades = 2; %OK
% Radiu of spinning propeller
Vehicle.Rotor.radius = 0.128; %OK

% Thickness of the blade??? I measure in the widest point
Vehicle.Rotor.chord = .027; 

Vehicle.Rotor.flappingOffset = 0; % Not changed
% Whole propeller mass??? or single blade, I used the whole propeller mass
Vehicle.Rotor.bladeMass = .009; 

Vehicle.Rotor.bladeInertia = Vehicle.Rotor.bladeMass*Vehicle.Rotor.radius^2/4; 
Vehicle.Rotor.hubMass = 0; % Not changed
Vehicle.Rotor.hubInertia = 0; % Not changed
Vehicle.Rotor.inertia = Vehicle.Rotor.hubInertia + Vehicle.Rotor.bladeInertia; 
% Thrust cooficient calculated from the equation for w2ToThrustGain.
% Omega^2 was estimated from similar motor properties:
% Voltage: 11.1 V
% Current: 9.5 A
% Power: 105 W
% KV: 920
% Pull (Thrust) generated by propeller in gramms: 642 g
% T = (642/1000) * 9.81 = 6.30 N
% n = 920 * 11.1 / 60 = 170.52 rps
% Using the formula P = 2πNT/60, where P is power in watts, 
% N is propeller RPS, and T is thrust in Newtons, we can solve for N:
% N = (60 x P) / (2π x T)
% N = (60 x 105) / (2π x 6.3)
% N = 159.1549 rps
% w^2 = (159.1549 * 2 * pi)^2 = 1.0000e+06
Vehicle.Rotor.Ct = 0.0063; 
Vehicle.Rotor.Cq = Vehicle.Rotor.Ct*sqrt(Vehicle.Rotor.Ct/2);
Vehicle.Rotor.solidity = Vehicle.Rotor.chord*Vehicle.Rotor.blades/(pi*Vehicle.Rotor.radius);
Vehicle.Rotor.theta0 = 14.6*(pi/180);
Vehicle.Rotor.thetaTip = 6.8*(pi/180);
Vehicle.Rotor.theta1 = Vehicle.Rotor.thetaTip-Vehicle.Rotor.theta0;
Vehicle.Rotor.theta34 = Vehicle.Rotor.theta0+0.75*Vehicle.Rotor.theta1;
% Vehicle.Rotor.a = 5.5; % Lift slope
% Got little help from chatgpt - this is typical value for airfoil NACA
% 4412, I am not sure if that specific airofoil is the airfoil of my
% propeller and if this is a proper value for this airfoil
Vehicle.Rotor.a = 0.109; 

Vehicle.Rotor.area = pi*Vehicle.Rotor.radius^2;
Vehicle.Rotor.lock = rho*Vehicle.Rotor.a*Vehicle.Rotor.chord*Vehicle.Rotor.radius^4/...
    (Vehicle.Rotor.hubInertia+Vehicle.Rotor.bladeInertia);
Vehicle.Rotor.b = Vehicle.Rotor.Ct*rho*Vehicle.Rotor.area*Vehicle.Rotor.radius^2;
Vehicle.Rotor.k = Vehicle.Rotor.Cq*rho*Vehicle.Rotor.area*Vehicle.Rotor.radius^3;
Vehicle.Rotor.w2ToThrustGain = Vehicle.Rotor.Ct*rho*Vehicle.Rotor.area*Vehicle.Rotor.radius^2;

% Motors
Vehicle.Motor.maxLimit = 1000;
Vehicle.Motor.minLimit = 30;
% Calculate dependency between 
% Vehicle.Motor.commandToW2Gain = 58; %motor command for Rolling Spider % (0-500) to motorspeed^2 - teoretycznie poprawne, poprawka na nową prędkość w (omega) plus wcześniej trzeba chyba było pomnożyć przez 10, bo PWM był w procentach a nie promilach
% Vehicle.Motor.commandToW2Gain = 58*5.1148;
Vehicle.Motor.commandToW2Gain = 2294.4;

Vehicle.Motor.thrustToMotorCommand = 1/(Vehicle.Rotor.w2ToThrustGain*Vehicle.Motor.commandToW2Gain);