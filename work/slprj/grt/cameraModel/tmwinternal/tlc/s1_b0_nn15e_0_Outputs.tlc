%implements s1_b0_nn15e_0_Outputs "C"

%function Outputs(block, system) Output
%assign cfgTxt = ""
%openfile cfgTxt
%assign localVarDecl = ""
%openfile localVarDecl

int32_T i;
int32_T indxI;
int32_T indxO;
int32_T j;
int32_T plane;
int32_T planeOffset;
uint8_T rtb_Blue;
uint8_T rtb_Green;
uint8_T rtb_Red;
%closefile localVarDecl
%assign tlcOutputsFcnOfS0B0 = OpaqueTLCBlockFcn("Outputs", 0, 0, 0, 1, 0)
%if !WHITE_SPACE(tlcOutputsFcnOfS0B0)
/* {S!d30}S-Function (vrsfunc): '<Root>/On-Board Camera' */
%<tlcOutputsFcnOfS0B0>\
%endif
/* {S!d32}S-Function (sviprotate): '<Root>/Rotate' incorporates:
 *  S-Function (vrsfunc): '<Root>/On-Board Camera'
 */
indxI = 0;
planeOffset = 119;
for (plane = 0; plane < 3; plane++) {
    for (i = 0; i < 120; i++) {
        indxO = planeOffset - i;
        for (j = 0; j < 160; j++) {
            cameraModel_B.Rotate[indxO] = cameraModel_B.OnBoardCamera[indxI];
            indxI++;
            indxO += 120;
        }
    }
    planeOffset += 19200;
}
/* {E!d32}End of S-Function (sviprotate): '<Root>/Rotate' */
for (plane = 0; plane < 160; plane++) {
    /* {S!d34}Selector: '<S1>/Blue' incorporates:
 *  S-Function (sviprotate): '<Root>/Rotate'
 */
    memcpy(&cameraModel_B.Blue[plane * 120], &cameraModel_B.Rotate[plane * 120 + 38400], 120U * sizeof(uint8_T));
    /* {S!d36}Selector: '<S1>/Red' incorporates:
 *  S-Function (sviprotate): '<Root>/Rotate'
 */
    memcpy(&cameraModel_B.Red[plane * 120], &cameraModel_B.Rotate[plane * 120], 120U * sizeof(uint8_T));
    /* {S!d38}Selector: '<S1>/Green' incorporates:
 *  S-Function (sviprotate): '<Root>/Rotate'
 */
    memcpy(&cameraModel_B.Green[plane * 120], &cameraModel_B.Rotate[plane * 120 + 19200], 120U * sizeof(uint8_T));
}
/* {S!d40}S-Function (svipcolorconv): '<S1>/Color Space  Conversion' incorporates:
 *  Selector: '<S1>/Blue'
 *  Selector: '<S1>/Green'
 *  Selector: '<S1>/Red'
 */
for (i = 0; i < 19200; i++) {
    rtb_Blue = cameraModel_B.Blue[i];
    rtb_Green = cameraModel_B.Green[i];
    rtb_Red = cameraModel_B.Red[i];
    cameraModel_B.ColorSpaceConversion_o1[i] = (uint8_T)((((rtb_Red * 16829U + rtb_Green * 33039U) + rtb_Blue * 6416U) + 1081344U) >> 16);
    cameraModel_B.ColorSpaceConversion_o2[i] = (uint8_T)((((rtb_Blue * 28784U - rtb_Red * 9714U) - rtb_Green * 19071U) + 8421376U) >> 16);
    cameraModel_B.ColorSpaceConversion_o3[i] = (uint8_T)((((rtb_Red * 28784U - rtb_Blue * 4681U) - rtb_Green * 24103U) + 8421376U) >> 16);
}
/* {E!d40}End of S-Function (svipcolorconv): '<S1>/Color Space  Conversion' */

/* {S!d42}Math: '<S1>/Transpose1' incorporates:
 *  S-Function (svipcolorconv): '<S1>/Color Space  Conversion'
 */
for (plane = 0; plane < 120; plane++) {
    for (i = 0; i < 160; i++) {
        cameraModel_B.Blue[i + 160 * plane] = cameraModel_B.ColorSpaceConversion_o1[120 * i + plane];
    }
}
/* {E!d42}End of Math: '<S1>/Transpose1' */

/* {S!d44}Selector: '<S1>/y1' incorporates:
 *  Constant: '<S1>/Constant'
 */
for (i = 0; i < 9600; i++) {
    cameraModel_B.MatrixConcatenate[i] = cameraModel_B.Blue[(int32_T)cameraModel_P_g.Constant_Value[i] - 1];
}
/* {E!d44}End of Selector: '<S1>/y1' */

/* {S!d46}Math: '<S1>/Transpose2' incorporates:
 *  S-Function (svipcolorconv): '<S1>/Color Space  Conversion'
 */
for (plane = 0; plane < 120; plane++) {
    for (i = 0; i < 160; i++) {
        cameraModel_B.Red[i + 160 * plane] = cameraModel_B.ColorSpaceConversion_o2[120 * i + plane];
    }
}
for (i = 0; i < 9600; i++) {
    /* {S!d48}Selector: '<S1>/u' incorporates:
 *  Constant: '<S1>/Constant2'
 *  Math: '<S1>/Transpose2'
 */
    cameraModel_B.MatrixConcatenate[i + 9600] = cameraModel_B.Red[(int32_T)cameraModel_P_g.Constant2_Value[i] - 1];
    /* {S!d50}Selector: '<S1>/y2' incorporates:
 *  Constant: '<S1>/Constant1'
 */
    cameraModel_B.MatrixConcatenate[i + 19200] = cameraModel_B.Blue[(int32_T)cameraModel_P_g.Constant1_Value[i] - 1];
}
/* {S!d52}Math: '<S1>/Transpose3' incorporates:
 *  S-Function (svipcolorconv): '<S1>/Color Space  Conversion'
 */
for (plane = 0; plane < 120; plane++) {
    for (i = 0; i < 160; i++) {
        cameraModel_B.Red[i + 160 * plane] = cameraModel_B.ColorSpaceConversion_o3[120 * i + plane];
    }
}
for (plane = 0; plane < 9600; plane++) {
    /* {S!d54}Selector: '<S1>/v' incorporates:
 *  Constant: '<S1>/Constant3'
 *  Math: '<S1>/Transpose3'
 */
    cameraModel_B.MatrixConcatenate[plane + 28800] = cameraModel_B.Red[(int32_T)cameraModel_P_g.Constant3_Value[plane] - 1];
    /* {S!d56}Math: '<S1>/Transpose' incorporates:
 *  Concatenate: '<S1>/Matrix Concatenate'
 */
    i = plane << 2;
    rty_image_data[i] = cameraModel_B.MatrixConcatenate[plane];
    rty_image_data[i + 1] = cameraModel_B.MatrixConcatenate[plane + 9600];
    rty_image_data[i + 2] = cameraModel_B.MatrixConcatenate[plane + 19200];
    rty_image_data[i + 3] = cameraModel_B.MatrixConcatenate[plane + 28800];
}
%closefile cfgTxt
%<cfgTxt>
%assign rtmArgSys = ::CompiledModel.System[::CompiledModel.System[::CompiledModel.RTWCGModules.RTWCGModule[0].CGSystemIdx].NonInlinedParentSystemIdx]
%if SysFcnArgNeeded("Output", rtmArgSys.Interface.RTMArgDef, rtmArgSys.CurrentTID, FcnSysModuleIsRateGrouping(rtmArgSys, "Output"))
%<SLibCG_AccessArg(0, 1, 0)>
%endif
%if SLibCG_ArgAccessed(0, 1, 0)
%<SLibAccessArg(rtmArgSys.Interface.RTMArgDef, "Output", rtmArgSys.CurrentTID, FcnSysModuleIsRateGrouping(rtmArgSys, "Output"))>
%endif
%if (IsModelReferenceBaseSys(rtmArgSys) && (IsModelRefScalableBuild() || GenerateClassInterface)) ||...
(GenerateClassInterface && SLibIsMultiInstanceServer(rtmArgSys))
%<SLibCG_UndoAccessArg(0, 1, 0)>
%endif
%<LibSetSystemField(system, "CachedOutputLocalVars", localVarDecl)>
%endfunction
%function OutputsFcnProtoType(block, system) Output
%assign fcnProtoType = ""
%openfile fcnProtoType
static void cameraModel(\
%assign comma = ""
%if SLibCG_ArgAccessed(0, 1, 0)
%<comma>%<::tSimStructType> * const %<::tSimStruct>\
%assign comma = ", "
%<SLibUpdateSymbolForFunction("cameraModel", SLibGetFcnDefinitionRTMSymbolName(), TLC_FALSE)>\
%endif
%<comma>uint8_T rty_image_data[38400]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 1, fcnProtoType)>
%endfunction
